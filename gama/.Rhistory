# plota a curva
curve(f, min, max, n = 1000)
# executa a busca
GA <- ga(type = "real-valued", fitness = f, min = min, max = max, monitor = FALSE)
# imprime resultados
summary(GA)
# adiciona o melhor valor na curva anteriormente plotada
points(GA@solution, GA@fitnessValue, col = 2, pch = 19)
# https://cran.r-project.org/web/packages/GA/vignettes/GA.html
# na primeira execução, é necessário instalar o pacote
# install.packages("GA")
# inclusão do pacote
library(GA)
# definição da função
f <- function(x)  (x^3)
# estabelece limites max e min para o espaço de busca
min <- -10; max <- 10
# plota a curva
curve(f, min, max, n = 1000)
# executa a busca
GA <- ga(type = "real-valued", fitness = f, min = min, max = max, monitor = FALSE)
# imprime resultados
summary(GA)
# adiciona o melhor valor na curva anteriormente plotada
points(GA@solution, GA@fitnessValue, col = 2, pch = 19)
# https://cran.r-project.org/web/packages/GA/vignettes/GA.html
# na primeira execução, é necessário instalar o pacote
# install.packages("GA")
# inclusão do pacote
library(GA)
# definição da função
f <- function(x)  (x^3)
# estabelece limites max e min para o espaço de busca
min <- -10; max <- 10
# plota a curva
curve(f, min, max, n = 1000)
# executa a busca
GA <- ga(type = "real-valued", fitness = f, min = min, max = max, monitor = FALSE)
# imprime resultados
summary(GA)
# adiciona o melhor valor na curva anteriormente plotada
points(GA@solution, GA@fitnessValue, col = 2, pch = 19)
# https://cran.r-project.org/web/packages/GA/vignettes/GA.html
# na primeira execução, é necessário instalar o pacote
# install.packages("GA")
# inclusão do pacote
library(GA)
# definição da função
f <- function(x)  (x^3)
# estabelece limites max e min para o espaço de busca
min <- -10; max <- 10
# plota a curva
curve(f, min, max, n = 1000)
# executa a busca
GA <- ga(type = "real-valued", fitness = f, min = min, max = max, monitor = FALSE)
# imprime resultados
summary(GA)
# adiciona o melhor valor na curva anteriormente plotada
points(GA@solution, GA@fitnessValue, col = 2, pch = 19)
# https://cran.r-project.org/web/packages/GA/vignettes/GA.html
# na primeira execução, é necessário instalar o pacote
# install.packages("GA")
# inclusão do pacote
library(GA)
# definição da função
f <- function(x)  (x^3)
# estabelece limites max e min para o espaço de busca
min <- -10; max <- 10
# plota a curva
curve(f, min, max, n = 1000)
# executa a busca
GA <- ga(type = "real-valued", fitness = f, min = min, max = max, monitor = FALSE)
# imprime resultados
summary(GA)
# adiciona o melhor valor na curva anteriormente plotada
points(GA@solution, GA@fitnessValue, col = 2, pch = 19)
# https://cran.r-project.org/web/packages/GA/vignettes/GA.html
# na primeira execução, é necessário instalar o pacote
# install.packages("GA")
# inclusão do pacote
library(GA)
# definição da função
f <- function(x)  (x^3)
# estabelece limites max e min para o espaço de busca
min <- -10; max <- 10
# plota a curva
curve(f, min, max, n = 1000)
# executa a busca
GA <- ga(type = "real-valued", fitness = f, min = min, max = max, monitor = FALSE)
# imprime resultados
summary(GA)
# adiciona o melhor valor na curva anteriormente plotada
points(GA@solution, GA@fitnessValue, col = 2, pch = 19)
# https://cran.r-project.org/web/packages/GA/vignettes/GA.html
# na primeira execução, é necessário instalar o pacote
# install.packages("GA")
# inclusão do pacote
library(GA)
# definição da função
f <- function(x)  (x^3)*cos(x)^2*sinh(x)^3
# estabelece limites max e min para o espaço de busca
min <- -10; max <- 10
# plota a curva
curve(f, min, max, n = 1000)
# executa a busca
GA <- ga(type = "real-valued", fitness = f, min = min, max = max, monitor = FALSE)
# imprime resultados
summary(GA)
# adiciona o melhor valor na curva anteriormente plotada
points(GA@solution, GA@fitnessValue, col = 2, pch = 19)
lybrary("GA")
library("GA")
library("GA")
library("GA")
# 1) one-dimensional function
f <- function(x)  abs(x)+cos(x)
curve(f, -20, 20)
fitness <- function(x) -f(x)
GA <- ga(type = "real-valued", fitness = fitness, lower = -20, upper = 20)
summary(GA)
plot(GA)
curve(f, -20, 20)
abline(v = GA@solution, lty = 3)
library("GA")
# 1) one-dimensional function
f <- function(x)  abs(x)+cos(x)
curve(f, -20, 20)
fitness <- function(x) -f(x)
GA <- ga(type = "real-valued", fitness = fitness, lower = -20, upper = 20)
summary(GA)
plot(GA)
curve(f, -20, 20)
abline(v = GA@solution, lty = 3)
library("GA")
# 1) one-dimensional function
f <- function(x)  abs(x)+cos(x)
curve(f, -20, 20)
fitness <- function(x) -f(x)
GA <- ga(type = "real-valued", fitness = fitness, lower = -20, upper = 20)
summary(GA)
plot(GA)
curve(f, -20, 20)
abline(v = GA@solution, lty = 3)
library("GA")
# 1) one-dimensional function
f <- function(x)  abs(x)+cos(x)
curve(f, -20, 20)
fitness <- function(x) -f(x)
GA <- ga(type = "real-valued", fitness = fitness, lower = -20, upper = 20)
summary(GA)
plot(GA)
curve(f, -20, 20)
abline(v = GA@solution, lty = 3)
curve(f, -10, 10)
# write your own tracing function
monitor <- function(obj)
{
curve(f, -10, 10, main = paste("iteration =", obj@iter))
points(obj@population, obj@fitness, pch = 20, col = 2)
rug(obj@population, col = 2)
Sys.sleep(0.2)
}
GA <- ga(type = "real-valued", fitness = f, lower = -10, upper = 10, monitor = monitor)
source('~/Dropbox/Academico/Doutorado/2018.1/optimization/ga-test.r')
library("GA")
# 1) one-dimensional function
f <- function(x)  abs(x)+cos(x)
curve(f, -20, 20)
fitness <- function(x) -f(x)
GA <- ga(type = "real-valued", fitness = fitness, lower = -20, upper = 20)
# 1) one-dimensional function
f <- function(x)  abs(x)+cos(x)
curve(f, -20, 20)
fitness <- function(x) -f(x)
GA <- ga(type = "real-valued", fitness = fitness, lower = -20, upper = 20)
GA <- ga(type = "real-valued", fitness = fitness, lower = -20.0, upper = 20.0)
GA <- ga(type = "real-valued", fitness = fitness, min = -20.0, max = 20.0)
summary(GA)
shuffle(20)
library(permute)
vec <- c(3,4,5)
vec
allPerms(vec)
vec1 <- check(1:100)
vec2 <- check(1:100, how())
vec1
shuffle(5)
shuffle(5)
shuffle(5)
shuffle(5)
shuffle(5)
shuffle(n)
shuffle(200)
plts <- gl(4, 10) ## 4 Plots of 10 samples each
plts
blks <- gl(2, 20) ## 2 Blocks of 20 samples each
blks
h1 <- how(within = Within(type = "series", mirror = TRUE),
plots = Plots(strata = plts, type = "series"),
blocks = blks)
update(h1, blocks = NULL)
plots2 <- update(getPlots(h1), type = "none")
update(h1, plots = plots2)
sample(1:5. 1309, replace=T)
sample(1:5, 1309, replace=T)
sample(1:5, 1309, replace=T, prob(0.25, 0.5, 0.75))
sample(1:5, 1309, replace=T, prob = c(0.25, 0.5, 0.75))
source('~/Dropbox/Academico/Doutorado/CompBioInspirada/optimization/eniac/gama/ga-final-search.r')
setwd("~/Dropbox/Academico/Doutorado/CompBioInspirada/optimization/eniac/ga/")
library(cluster)
silhouette()
library(GA)
citation("GA")
ptions(citation.bibtex.max=999)
options(citation.bibtex.max=999)
citation("GA")
citation("dbscan")
citation("Rfast")
# setwd
this.dir <- dirname(sys.frame(1)$ofile)
setwd(this.dir)
#R CMD BATCH '--args large 1000 25' gamas.r gamas.out
library(GA)
library(cluster)
library(Rfast)
# fitness_asw_nopenalty <- function(palpite) {
#   m.palpite <- matrix(palpite,nrow = k,ncol = dimen)
#   which.dists <- apply(dista(cpu.norm, m.palpite,
#                              "euclidean", square = TRUE), 1, which.min)
#
#   asw   <- silhouette(which.dists, d2)
#
#   # tenta o cálculo da silhueta
#   # retorna neutro (0) em caso de erro
#   # observação: não descobri qual o erro
#   sm <- tryCatch(summary(asw)$avg.width, error = function (e) { return (0)})
#
#   return (sm)
# }
fitness_asw <- function(palpite) {
m.palpite <- matrix(palpite,nrow = k,ncol = dimen)
sums <- apply(m.palpite, 1, sum)
overflow <- which(sums > 100)
num_constraints = length(overflow)
penalty = 0
if (num_constraints > 0) {
penalty <- num_constraints * max(abs(sums[overflow] -100)/sums[overflow])
}
which.dists <- apply(dista(cpu.norm, m.palpite, "euclidean", square = TRUE), 1, which.min)
asw   <- silhouette(which.dists, d2)
# tenta o cálculo da silhueta
# retorna neutro (0) em caso de erro
sm <- tryCatch(summary(asw)$avg.width, error = function (e) { return (0)})
return (sm - penalty)
}
pop.f <- function(object) {
lower <- object@lower
upper <- object@upper
nvars <- length(lower)
population <- matrix(as.double(NA), nrow = object@popSize, ncol = nvars)
for(j in 1:nvars)
{ population[,j] <- runif(object@popSize, lower[j], upper[j]) }
# valida cada conjunto de pontos (population [i,1:4])
for(i in 1:object@popSize) {
# diminui o valor de cada linha até que o somatório seja <= 100
repeat {
# quais linhas (1:k) do individuo na populacao (1:popSize) sao maiores que 100
m <- matrix(population[i,], ncol = 4, nrow = 5)
sums <- apply(m, 1, sum)
w.sums <- which(sums > 100)
# para o laco repeat quando a quantidade de linhas com somatorio > 100 for igual a 0
if (length(w.sums) == 0){
break
} else {
# diminui o valor de cada linha em uma proporção equivalente a cada dimensão sobre o total
for (y in w.sums) {
# calcula a proporção sobre a o indivíduo desnormalizado
prop_over_all <- m[y,]/sums[y]
m[y, ] <- m[y, ] - prop_over_all
population[i,] <- as.vector(m)
}
}
}
}
return(population)
}
# ==== PARÂMETROS ====
# R CMD BATCH '--args scale = large'
args=(commandArgs(TRUE))
if (length(args)!=3) {
stop("Give the data volume scale, the number of generations and iterations.n", call.=FALSE)
}
#eval(parse(text=args[[1]]))
scale = args[[1]]
generations = as.integer(args[[2]])
iterations = as.integer(args[[3]])
print(args)
#for (scale in scales) {
k = 5 # cluster
#cpu <- read.csv(paste("data/data-", scale, ".csv", sep=""))
cpu.norm <- read.csv(paste("data/data-", scale, ".csv", sep=""))
# dimensions
dimen = ncol(cpu.norm)
# distance matrix
d <- dist(cpu.norm, method = "euclidean", diag = FALSE, upper = FALSE)
d2 <- d^2
rm(d)
gc()
# lower and upper bounds for the operators
lower_bound <-  c(rep(min(cpu.norm[, 1]), k), rep(min(cpu.norm[, 2]), k), rep(min(cpu.norm[, 3]), k), rep(min(cpu.norm[, 4]), k))
upper_bound <-  c(rep(max(cpu.norm[, 1]), k), rep(max(cpu.norm[, 2]), k), rep(max(cpu.norm[, 3]), k), rep(max(cpu.norm[, 4]), k))
s <- "gareal_lsSelection"
m <- "gareal_rsMutation"
c <- "gareal_blxCrossover"
sl = "linScaling"
cl = "blend"
ml = "randAroundSol"
pop.r <- 50
cross.r <- 0.9
mut.r <- 0.01
#generations <- 10
# elitismo = 5% da populacao
elit.r = floor(pop.r * 0.05)
# numero de iteracoes
#iterations = 1
asw <- c()
solution <- list()
for (w in 1:iterations) {
print(paste(scale, "Iter: ", w, sep = (" ")))
# para que a seed seja diferente dos primeiros experimentos
seed = w*100
start.time <- Sys.time()
genetic <- ga(type = "real-valued",
seed = w,
population = pop.f,
selection = s, mutation = m, crossover = c,
popSize = pop.r, elitism = elit.r, pmutation = mut.r, pcrossover = cross.r,
maxiter = generations, maxFitness = 1.0, fitness = fitness_asw,
lower = lower_bound,
upper = upper_bound,
monitor = FALSE)
end.time <- Sys.time()
# ==== COMPUTA O ASW =====
# se o GA retornou apenas uma solução
individuo = NA
num_sols = length(genetic@solution)/(k*dimen)
if (num_sols == 1) {
individuo <- matrix(genetic@solution,nrow = k,ncol = dimen)
} else {
# se o GA retornou mais que uma solução (toma a primeira, igual fitness)
individuo <- matrix(genetic@solution[1,],nrow = k,ncol = dimen)
}
which.dists <- apply(dista(cpu.norm, individuo, "euclidean", square = TRUE), 1, which.min)
asw[w] <- summary(silhouette(which.dists, d2))$avg.width
solution[[w]] <- which.dists
t <- as.data.frame(individuo)
colnames(t) <- colnames(cpu.norm)
t <- t[with(t, order(user + system + softirq + iowait)), ]
sink(file=paste(scale,"/points_data.dat", sep = ""), append = TRUE)
print(t)
cat("\n")
sink()
sink(file=paste(scale,"/sol_data.dat", sep=""), append = TRUE)
cat(solution[[w]])
cat("\n")
sink()
sink(file=paste(scale,"/summary_data.dat", sep=""), append = TRUE)
cat(asw[[w]])
cat("\n")
sink()
rm(genetic, which.dists)
}
sink(file=paste(scale,"/summary_data.dat", sep=""), append = TRUE)
print(summary(asw))
cat("\n")
sink()
rm(d2)
gc()
#}
setwd("~/git/gama/gama")
library(GA)
library(cluster)
fitness_asw <- function(individual) {
asw   <- summary(silhouette(round(individual), d2))$avg.width
penalty = 0
if (asw < 0)
penalty =
return (asw - penalty)
}
k = 5 # cluster
cpu <- read.csv("cpu-large.csv")
# distance matrix
d <- dist(cpu, method = "euclidean", diag = FALSE, upper = FALSE)
d2 <- d^2
# lower and upper bounds for the operators
lower_bound <- rep(1,1309)
upper_bound <- rep(5,1309)
s <- "gareal_lrSelection"
c <- "gareal_blxCrossover"
m <- "gareal_nraMutation"
pop.r <- 200
cross.r <- 0.8
mut.r <- 0.1
generations <- 100000
elit.r = floor(pop.r * 0.05)
start.time <- Sys.time()
sol <- read.csv("sol_data.dat", sep = " ")
mat <- matrix(NA, ncol = 1309, nrow = 25)
mat[1, ] <- as.integer(sol[1,])
mat[2, ] <- as.integer(sol[2,])
mat[3, ] <- as.integer(sol[3,])
genetic <- ga(type = "real-valued",
seed = 42,
elitism = floor(pop.r * 0.05),
suggestions = mat,
selection = s,
crossover = c,
mutation = m,
pcrossover = cross.r,
pmutation = mut.r,
lower = lower_bound,
upper = upper_bound,
popSize = pop.r,
maxiter = generations,
keepBest = TRUE,
fitness = fitness_asw,
parallel = F,
monitor = T)
genetic <- ga(type = "real-valued",
seed = 42,
elitism = floor(pop.r * 0.05),
#suggestions = mat,
selection = s,
crossover = c,
mutation = m,
pcrossover = cross.r,
pmutation = mut.r,
lower = lower_bound,
upper = upper_bound,
popSize = pop.r,
maxiter = generations,
keepBest = TRUE,
fitness = fitness_asw,
parallel = F,
monitor = T)
source('~/git/gama/gama/gama-int-GA.R')
source('~/git/gama/gama/gama-int-GA.R')
pop.f <- function(object) {
sol <- read.csv("sol_data.dat", sep = " ")
mat <- matrix(NA, ncol = 1309, nrow = 25)
mat[1, ] <- as.integer(sol[1,])
mat[2, ] <- as.integer(sol[2,])
mat[3, ] <- as.integer(sol[3,])
return(mat)
}
debugSource('~/git/gama/gama/gama-int-GA.R')
sol
mat
source('~/git/gama/gama/gama-int-GA.R')
source('~/git/gama/gama/gama-int-GA.R')
debugSource('~/git/gama/gama/gama-int-GA.R')
debugSource('~/git/gama/gama/gama-int-GA.R')
object
debugSource('~/git/gama/gama/gama-int-GA.R')
debugSource('~/git/gama/gama/gama-int-GA.R')
mat[, i] <- as.integer(sol[1,])
mat[, 1] <- as.integer(sol[1,])
mat[, 1]
object@popSize
debugSource('~/git/gama/gama/gama-int-GA.R')
mat[, 1] <- as.integer(sol[1,])
mat[1, ] <- as.integer(sol[1,])
mat[1,]
debugSource('~/git/gama/gama/gama-int-GA.R')
mat[i,] <- as.integer(sol[1,])
debugSource('~/git/gama/gama/gama-int-GA.R')
debugSource('~/git/gama/gama/gama-int-GA.R')
source('~/git/gama/gama/gama-int-GA.R')
source('~/git/gama/gama/gama-int-GA.R')
debugSource('~/git/gama/gama/gama-int-GA.R')
debugSource('~/git/gama/gama/gama-int-GA.R')
t(mat)
sol[1,]
sol[2,]
sol[24,]
sol[25,]
as.integer(sol[25,])
debugSource('~/git/gama/gama/gama-int-GA.R')
debugSource('~/git/gama/gama/gama-int-GA.R')
asw
source('~/git/gama/gama/gama-int-GA.R')
plot(genetic)
plot(genetic)
source('~/git/gama/gama/gama-int-GA.R')
plot(genetic)
runif(1309, 1, 5) }
runif(1309, 1, 5)
round(runif(1309, 1, 5) )
source('~/git/gama/gama/gama-int-GA.R')
plot(genetic )
source('~/git/gama/gama/gama-int-GA.R')
source('~/git/gama/gama/gama-int-GA.R')
source('~/git/gama/gama/gama-int-GA.R')
plot(genetic )
genetic@solution
as.integer(genetic@solution)
source('~/git/gama/gama/gama-int-GA.R')
floor(pop.r * 0.05)
source('~/git/gama/gama/gama-int-GA.R')
plot(genetic )
source('~/git/gama/gama/gama-int-GA.R')
plot(genetic )

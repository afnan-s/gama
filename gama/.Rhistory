plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x="right",
y=7,
bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=0.75, y = 0.25, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=0.9, y = 0.25, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=12, y = 0.25, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=50, y = 15, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=50, y = 3, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=50, y = 0.5, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=20, y = 0.5, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=30, y = 1.5, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=27, y = 3.5, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x="top", y = 3.5, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=27, y = 3.5, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
plot.dimensions.f(scale(cpu.large), sol_gama)
plot.dimensions.f(cpu.large, sol_km)
plot.dimensions.f(cpu.large, sol_gama)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=27, y = 3.5, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
plot.dimensions.f(scale(cpu.large), sol_gama)
# plot.dimensions.f(cpu.large, sol_km)
# plot.dimensions.f(cpu.large, sol_gama)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=27, y = 3.5, bty = "n"
))
}
plot.dimensions.f(scale(cpu.large), sol_km)
plot.dimensions.f(scale(cpu.large), sol_gama)
# plot.dimensions.f(cpu.large, sol_km)
# plot.dimensions.f(cpu.large, sol_gama)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=27, y = 3.5, bty = "n"
))
print(zz)
}
plot.dimensions.f(scale(cpu.large), sol_km)
plot.dimensions.f(scale(cpu.large), sol_gama)
# plot.dimensions.f(cpu.large, sol_km)
# plot.dimensions.f(cpu.large, sol_gama)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow=5, byrow=F ))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=27, y = 3.5, bty = "n"
))
print(z)
}
plot.dimensions.f(scale(cpu.large), sol_km)
plot.dimensions.f(scale(cpu.large), sol_gama)
# plot.dimensions.f(cpu.large, sol_km)
# plot.dimensions.f(cpu.large, sol_gama)
plot.dimensions.f(cpu.large, sol_km)
debugSource('~/git/feature_eng/plot_dimensions.r', echo=TRUE)
dat
debugSource('~/git/feature_eng/plot_dimensions.r', echo=TRUE)
dat
debugSource('~/git/feature_eng/plot_dimensions.r', echo=TRUE)
dat [1:5,]
z[1:5,]
tmp
z
tmp
z<- data.frame(t(matrix(unlist(tmp)), nrow=5, byrow=F ))
z<- data.frame(t(matrix(t(unlist(tmp))), nrow=5, byrow=F ))
unlist(tmp)
matrix(unlist(tmp), nrow=5, byrow=F )
z
t
tmp
z
unlist(tmp)
matrix(unlist(tmp)
)
matrix(unlist(tmp))
matrix(unlist(tmp), nrow = 5)
matrix(unlist(tmp), ncol = 4)
matrix(unlist(tmp), ncol = 4, byrow = F)
matrix(unlist(tmp), ncol = 4, byrow = T)
matrix(unlist(tmp), nrow = 5, ncol = 4, byrow = T)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow = 5, ncol = 4, byrow = T))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=27, y = 3.5, bty = "n"
))
print(z)
}
plot.dimensions.f(cpu.large, sol_km)
plot.dimensions.f(scale(cpu.large), sol_km)
plot.dimensions.f(cpu.large, sol_km)
plot.dimensions.f(cpu.large, sol_gama)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow = 5, ncol = 4, byrow = T))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3,5)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=27, y = 40.5, bty = "n"
))
print(z)
}
plot.dimensions.f(cpu.large, sol_km)
plot.dimensions.f(cpu.large, sol_gama)
range()
range(cpu.large)
plot.dimensions.f(cpu.large, sol_nkhga)
# depende de ler as soluções no repositório git/gama-remote
plot.dimensions.f <- function(dat, sol) {
l <- sapply(unique(sol), function(x) which(sol_gama == x))
tmp <- list()
i = 1
for (el in l) {
tmp[[i]] <- apply(dat[el, ], 2, mean)
i=i+1
}
z<- data.frame(matrix(unlist(tmp), nrow = 5, ncol = 4, byrow = T))
colnames(z) <- colnames(dat)
z$cluster <- c(1,2,4,3)
cores <- diverge_hcl(5, h = c(246,40), c=96)
zz <- as.matrix(z[-5])
barplot(zz, beside = T, legend.text = z$cluster,
col = cores, args.legend=list(
x=27, y = 40.5, bty = "n"
))
print(z)
}
plot.dimensions.f(cpu.large, sol_km)
plot.dimensions.f(cpu.large, sol_gama)
setwd("~/git/gama_remote/gama")
#   which.dists <- apply(dista(cpu.norm, m.palpite,
#                              "euclidean", square = TRUE), 1, which.min)
#
#   asw   <- silhouette(which.dists, d2)
#
#   # tenta o cálculo da silhueta
#   # retorna neutro (0) em caso de erro
#   # observação: não descobri qual o erro
#   sm <- tryCatch(summary(asw)$avg.width, error = function (e) { return (0)})
#
#   return (sm)
# }
fitness_asw <- function(palpite) {
m.palpite <- matrix(palpite,nrow = k,ncol = dimen)
sums <- apply(m.palpite, 1, sum)
overflow <- which(sums > 100)
num_constraints = length(overflow)
penalty = 0
if (num_constraints > 0) {
penalty <- num_constraints * max(abs(sums[overflow] -100)/sums[overflow])
}
which.dists <- apply(dista(cpu.norm, m.palpite, "euclidean", square = TRUE), 1, which.min)
asw   <- silhouette(which.dists, d2)
# tenta o cálculo da silhueta
# retorna neutro (0) em caso de erro
sm <- tryCatch(summary(asw)$avg.width, error = function (e) { return (0)})
return (sm - penalty)
}
pop.f <- function(object) {
lower <- object@lower
upper <- object@upper
nvars <- length(lower)
population <- matrix(as.double(NA), nrow = object@popSize, ncol = nvars)
for(j in 1:nvars)
{ population[,j] <- runif(object@popSize, lower[j], upper[j]) }
# valida cada conjunto de pontos (population [i,1:4])
for(i in 1:object@popSize) {
# diminui o valor de cada linha até que o somatório seja <= 100
repeat {
# quais linhas (1:k) do individuo na populacao (1:popSize) sao maiores que 100
m <- matrix(population[i,], ncol = 4, nrow = 5)
sums <- apply(m, 1, sum)
w.sums <- which(sums > 100)
# para o laco repeat quando a quantidade de linhas com somatorio > 100 for igual a 0
if (length(w.sums) == 0){
break
} else {
# diminui o valor de cada linha em uma proporção equivalente a cada dimensão sobre o total
for (y in w.sums) {
# calcula a proporção sobre a o indivíduo desnormalizado
prop_over_all <- m[y,]/sums[y]
m[y, ] <- m[y, ] - prop_over_all
population[i,] <- as.vector(m)
}
}
}
}
return(population)
}
# ==== PARÂMETROS ====
# R CMD BATCH '--args scale = large'
args=(commandArgs(TRUE))
if (length(args)!=3) {
stop("Give the data volume scale, the number of generations and iterations.n", call.=FALSE)
}
#eval(parse(text=args[[1]]))
scale = args[[1]]
generations = as.integer(args[[2]])
iterations = as.integer(args[[3]])
print(args)
source('~/git/gama_remote/gama/gama.r', echo=TRUE)
source('~/git/gama_remote/gama/gama.r', echo=TRUE)
